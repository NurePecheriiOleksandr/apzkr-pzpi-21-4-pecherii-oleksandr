Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: «Програмна система для автоматизації контролю занурення аквалангістів»
                                                  
Студент гр. ПЗПІ-21-4                          ________Печерій О. В.
	                                                                 (підпис)
Керівник роботи                                   _______________доц. Лещинська І.О.
	                                                                (підпис)

Роботу захищено «__»_________2024 р.
з оцінкою _________________________



Комісія:                                       __________________доц. Лещинський В.О.
	                                                         (підпис)
                                                       __________________доц. Лещинська І.О.
	                                                         (підпис)
                                                     __________________ст. викл. Сокорчук І.П.
	                                                         (підпис)


Харків 
2024
Аркуш завдання

Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук Кафедра програмної інженерії Спеціальність 121 – Інженерія програмного забезпечення
Курс	3	Семестр	6
Навчальна дисципліна Архітектура програмного забезпечення

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Печерій Олександра Володимировича
Тема проєкту: Програмна система для автоматизації контролю занурення аквалангістів.
Термін узгодження завдання курсової роботи «31» березня 2024 р.
Термін здачі студентом закінченої роботи «8» червня 2024 р.
Вихідні дані до проєкту: Програмна система для автоматизації контролю занурення аквалангістів Deep Dive - це система, головгою метою якої є оптимізація та автоматизація дайв-центрів. Користувачі системи зможуть відслідковувати стан дайверів, а також вносити дані до системи та керувати ними.
Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, тестування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки
Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): UML- діаграма розгортання, UML-діаграма прецедентів, UML- діаграма діяльності, ER- діаграма

КАЛЕНДАРНИЙ ПЛАН 

№
Основні етапи виконання проєкту в рамках лабораторних робіт 
Термін виконання етапів 
Примітка
1
Функціональна специфікація програмного проєкту  
22.02.2024
виконано
2
Проектування програмного проєкту
02.03.2024
виконано
3
Кодування програмного проєкту
03.04.2024
виконано
4
Оформлення пояснювальної записки
29.05.2024
виконано
5
Захист роботи
08.06.2024
виконано



Дата видачі теми проєкту «__12__»___лютого___2024 р.  
Керівник                    ______________ доц. Лещинська І. О.     (підпис)  
Завдання прийняв до виконання 
ст.гр. ПЗПІІ-21-4 _Печерій О. В.__ ____________ (підпис)



РЕФЕРАТ

Пояснювальна записка до курсової роботи: 56 с., 11 рис., 3 табл., 2
додатки, 6 джерел.
АКВАЛАНГ, ГЛИБИНА, ДІЯЛЬНІСТЬ, ЗАНУРЕННЯ, КЛУБ, КОМП’ЮТЕР, НИРЕЦЬ, ОРГАНІЗАТОР, СПОРЯДЖЕННЯ.

	Об’єктом дослідження є галузь водного спорту, а саме занурення з використанням аквалангу та іншого спорядження та організація цих занурень.
	Метою курсової роботи є розробка системи, яка буде зберігати інформацію про організаторів занурень, їх діяльності, таку як час, дату, місто, опис та список учасників в цій діяльності, інформацію про нирців, інформацію про спорядження, а також  інформацію стосовно глибини та часу занурення, зібрану з комп’ютеру для занурень.
	Методи розробки базуються на технології Django, серверу PostgreSQL, веб-додаток базується на технології React, смарт-пристрій розроблено на платі ESP32, датчику вимірювання глибини за допомогою Wokwi та мови програмування C++.
	У результаті роботи здійснено програмну реалізацію систему автоматизація аквалангічний занурень та управління діяльностями і прототип комп’ютеру для занурень для спостереження за станом нирця. Програмна система складається з веб-додатку, сервера та смарт-пристрою.


ЗМІСТ

Вступ……………………………………………………………………………6
1 Аналіз та концептуальне моделювання предметної області………………7
1.1	Бізнес-вимоги……………………………………………………………7
1.1.1	Бізнес можливості………………………………………………………7
1.1.2	Бізнес-цілі та критерії успіху…………………………………………..8
1.1.3	Потреби клієнтів або ринку…………………………………………….9
1.1.4	Бізнес-ризики……………………………………………………………9
1.2	Концепція рішення…………………………………………………….10
1.2.1	Окреслення концепції………………………………………………….10
1.2.2	Головна функціональність…………………………………………….11
1.2.3	Припущення та залежності……………………………………………12
1.3	Рамки та обмеження проєкту………………………………………….13
1.3.1	Рамки первинного випуску……………………………………………13
1.3.2	Рамки наступних випусків…………………………………………….13
1.3.3	Обмеження та винятки………………………………………………...14
1.4	Бізнес-контекст………………………………………………………...15
1.4.1	Профілі зацікавлених сторін………………………………………….15
1.4.2	Пріоритети проєкту……………………………………………………16
1.4.3	Робоче середовище…………………………………………………….16
2 Постановка задачі…………………………………………………………..18
3 Проектування програмного проєкту………………………………………20
3.1	Проектування серверної частини проєкту…………………………...20
3.2	Проектування IoT частини проєкту…………………………………..24
3.3	Проектування клієнтської частини проєкту………………………….25
4 Кодування програмного проєкту…………………………………………..27
4.1	Кодування серверної частини проєкту……………………………….27
4.1.1 Автоматизація розподілу спорядження……………………………….31
4.1.2    Створення копії бази даних………………………………………….32
4.1.3 Перевірка даних при вводі на правильність…………………………..33
4.2	Кодування IoT частини проєкту………………………………………33
4.3	Кодування клієнтської частини проєкту……………………………...35
4.3.1    Перевід значень глибини та часу…………………………………….37
Висновки………………………………………………………………………38
Перелік джерел посилання…………………………………………………...39
Додаток А……………………………………………………………………..40
Додаток Б……………………………………………………………………...54

ВСТУП

Індустрія занурень переживає значний ріст, завдяки збільшенню зацікавленості у зануреннях, дослідженні підводного світу та розвитку технологій. Усвідомлення важливості охорони морського середовища та популярність активного відпочинку у воді стимулюють попит на засоби автоматизації та підтримки для нирців.
Нирці можуть не пам'ятати про використання відповідного спорядження, що на перший погляд виглядає як невелика проблема, але може призвести до небезпечних ситуацій і непотрібних витрат. Не надання належної уваги до процесу занурень чи відсутність спостереження з боку організаторів може призвести до втрати часу та грошей, а також до зменшення задоволення від занурення.
Для наших бізнес-користувачів, таких як центри для занурень та школи для занурень, питання оптимізації управління зануреннями та автоматизація управління спорядженням є актуальними. Відсутність достатньої інформації про місця для дайвінгу, про нирців та обладнання може призвести до нераціонального використання зайвих ресурсів.
Ці проблеми підкреслюють актуальність розробленої програмної системи для автоматизації занурень. Система дозволяє легко занурюватися і додавати дані з комп’ютеру для занурень. Зберігаючи всю інформацію в додатку, користувачі можуть швидко і зручно отримати доступ до докладної інформації про кожну діяльність. Дана система є зручною та легкою в використанні, що збільшує кількість людей, що можуть їй використатися.

1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
	1.1	Бізнес-вимоги
	1.1.1    Бізнес-можливості

Розглядаючи ринок програмних систем для автоматизації контролю занурення аквалангистів, вже можно знайти існуючи аналоги. Прикладом такою системи може бути Geek Divers[1], яка призначення для керування клубами та курортами. В першу чергу, вона націлена на управління та слідкування за фінансами. Окрім цього, система надає графік доступних діяльностей клубу. Дана система є гарним рішенням для клубів різних розмірів, надаючи можливості з управління фінансами та діяльностями, але слід відмітити те, що дана система не надає ніякого контролю над аквалангічним спорядженням, що є однією із найважливіших частин управлінням організацією такого роду. Іншою аналогічною системою є Nautilus[2]. Nautilus представляє собою додаток, який має можливості аналогичні Geek Divers, а також можливість управління та керуванням спорядженням. Але даний аналог має технічні недоліки. Прикладом таких недоліків може бути те, що система представляє собою додаток на персональні комп'ютери, що є не настільки зручним інструментом як веб-додаток. Окрім цього, Nautilus це дуже стара система, яка була випущена ща у 1995 році та з тих пір майже не оновлювалась. Варто відмітити, що серед не аналогів не було знайдено систему, що крім надання управління клубом мало також б співпрацю з самим обладнанням, таким як, наприклад, декомпресійний комп'ютер.
З ріка в рік, занурення як спорт та вид відпочинку стає все більш популярним, тому даний напрям має дуже гарні перспективи, на що вказує зріст продажу спорядження для занурень.
Орієнтована монетизація проєкту буде відбуватися за рахунок співпраці з клубами, курортами та іншими організаціями, що надають послуги занурення.

	1.1.2    Бізнес-цілі та критерії успіху

Головні бізнес-цілі запропонованої системи полягають у підвищенні ефективності управління діяльностями з занурень, збільшенні рівня безпеки під час занурень та займання значного положення у ринку предметної області. Для досягнення зазначених цілей було встановлено наступні критерії успіху:
ВО-1: надати можливість людям спостерігати за діяльностями організаторів;
ВО-2: зменшити час підготовки до занурення;
ВО-3: підвищити зручність для організації відпочинку для любителей дайвинга;
	ВО-4: підвищити рівень безпеки для нирців та зменшити кількість травмування; 
Критерії успіху:
SC-1: встановлення системи більше ніж у 12 тисячах клубів для занурень;
SC-2: зниження витрат на управління клубом та організацію занурень на 15%.

1.1.3    Потреби клієнтів або ринку

Багато центрів занурень по всьому світу потребують засоби для ведення спостереження за нирцями під час їхніх занять, щоб забезпечити безпеку та підвищити рівень навчання та досвіду. За допомогою нашої системи, центри занурень зможуть забезпечити безпечні умови для занять зануреннями шляхом спостереження стану нирців, що також надає інструкторам більш детальну інформацію про нирців і може сприяти підвищенню якості навчання та досвіду.
Клієнти в даній області можуть мати різні потреби, коли мова йде про управління та організацію занурень та діяльностей. Вони шукають методи для спрощення процесу планування та проведення занурень, незалежно від складності чи місця проведення. Також важливо забезпечити спостереження за параметрами занурення в режимі реального часу, таких як глибина та час перебування під водою, що сприятиме підвищенню безпеки та ефективності занять.
Метою системи є задовольнити потреби ринків і клієнтів у автоматизації підводного плавання та зайняття свій долі ринку, надаючи зручні і ефективні рішення, що відповідають зростаючим потребам сучасних нирців та організаторів.

1.1.4    Бізнес-ризики

При впровадженні проєкту можуть виникнути ризики, пов'язані з конфіденційністю даних та технічними неполадками, що характерно для будь-якої системи. Проте варто також врахувати безпосередній ризик для безпеки нирців, особливо під час використання обладнання для спостереження. Неправильна обробка цих даних та аналізів може призвести до серйозних наслідків. Тому під час проектування важливо врахувати всі можливі аспекти, які можуть вплинути на безпеку та досвід нирців.
Крім того, можуть виникнути фінансові ризики, пов'язані з непередбачуваними витратами на розробку та обслуговування системи. Неправильна оцінка бюджету і незаплановані технічні неполадки можуть значно збільшити загальну вартість проекту. 
Також існують ризики, пов'язані з нормативними вимогами та стандартами безпеки. Недотримання відповідних норм і стандартів може призвести до юридичних наслідків, штрафів і втрати довіри з боку клієнтів. Важливо переконатися, що система відповідає всім відповідним нормативним вимогам і галузевим стандартам.
Нарешті, варто враховувати конкурентні ризики. Інші компанії можуть запропонувати подібні або більш зручні рішення, які можуть вплинути на позицію системи на ринку. Щоб залишатися конкурентоспроможними, необхідні постійні дослідження та адаптація до змін.

     
     1.2	    Концепція рішення
     1.2.1    Окреслення концепції
     

“Deep Dive” - це програмна система, яка складається з веб-додатку та IoT-пристрою, головною ціллю якої є управління зануреннями, контроль аквалангичного споряднення та занурення аквалангістів. Система буде дозволяти зберігати та редагувати усі необхідні дані про аквалангістів, що здійснюють занурення, дані про клуби чи школи, які відповідають за занурення та дані про обладнання, яке вони використовують. Крім цього система буде співпрацювати з декомпресійним комп'ютером аквалангістів, який буде надавати інформацію про глибину та температуру до організаторів. 
Після впровадження людям, що займаються дайвінгом буде значно легше планувати свій відпочинок, а підготовка до самих занурень буде займати меньше часу.

1.2.2	  Головна функціональність

	Головними функціями даного проєкту є надання можливості спостереження за станом людини під час занурення. Також проєкт буде мати наступні функції:
MF-1: Реєстрація та авторизація користувачів: Можливість реєстрації для користувачів та редагування інформації про себе;
MF-2: Розклад діяльності: Користувачеві буде доступний розклад найближчих діяльності центру занурення, що допоможе йому з плануванням свого відпочинку;
MF-3: Контроль занурення: Система буде надавати користувачеві усю небхідну інформацію занурення, таку як місце, час, кількість групи, тощо. Організаторам буде доступна інформація по кожному учаснику з його декомпресійного комп'ютера;
MF-4: Управління спорядженням: Організаторам занурення буде доступна можливість автоматично розподілити вільне аквалангичне спорядження серед групи;
MF-5: Веб доступ: Користувачі системи матимуть змогу скористатися системою через інтернет за допомогою веб-додатку. Це буде можливо через будь-який пристрій, який має доступ в інтернет.

1.2.3    Припущення та залежності


Під час проектування системи для занурення були зроблені наступні припущення щодо її функціонування:
-	нирці матимуть доступ до комп'ютерів для взаємодії з системою;
-	датчики для спостереження повинні бути закріплені на спорядження дайвера;
-	інформацію про безпеку та стан нирця будуть надавати самі нирці та інструктори;
-	вимірювання та передача даних про стан нирця може діяти не на всіх глибинах, а лише на тих, що дозволяє обладнання;
-	усе обладнання, відповідальне за спостереження дайверів, повинно бути правильно налаштоване та надійно працювати.
Також визначені такі залежності у системі:
-	для правильної роботи системи та доступу до даних необхідний інтернет-з'єднання;
-	спостереження за станом нирця залежить від використання сучасних технологій IoT;
-	наявність серверу для зберігання та обробки даних є важливою для ефективності системи для занурень.







1.3    Рамки та обмеження проєкту
1.3.1    Рамки первинного випуску


Первинний випуск продукту буде зосереджений на наданні основних для працювання функцій. Основні функції, які повинна включати серверна частина:
SIR-1: Реєстрація та авторизація до акаунта;
SIR-2: Перегляд графіку діяльності клубів та шкіл;
SIR-3: Спостереження за показниками людини під час занурення;
SIR-4: Автоматизація розподілу спорядження;
SIR-5: Керування даними про організаторів занурень;
SIR-6: CRUD операції;
SIR-7: Створення копії бази даних;
Програмне забезпечення пристрою IoT повинно включати:
SIR-8: Збір та відправлення даних про стан людини під час занурення;
Веб застосунок повинен включати:
SIR-9: Реєстрація та вхід для користувачів;
SIR-10: Функціонал адміністратора, що дозволяє керувати будь-якими даними у системі;
SIR-11: Графічний інтуїтивний інтерфейс;
SIR-12: Відображення даних у зручному форматі;


1.3.2    Рамки наступних випусків


Проєкт можу бути вдосконалений наступним шляхом у майбутньому:
SSR-1: Співпраця з магазинами спорядження та можливість придбання користувачами відповідного спорядження за допомогою інтернет способів оплати;
SSR-2: Вдосконалення комп’ютеру для занурень з функціоналом посилення сигналу екстреної допомоги в випадку загрози життя та безпеки нирця;
SSR-3: Створення бази навчальних матеріалів та системи тренувань для початкових нирців.


1.3.3	  Обмеження та винятки


Незважаючи на усі можливості, які надає данна система є певні обмеження та винятки, які повинні дотримуватись, а саме:
-	система може використовуватися по всьому світу, де розвинені занурення;
-	спорядження, зазначене в базі даних, може бути не в наявності чи не в робочому стані;
-	зазначена діяльність клубу може не статися через погодні умови чи інші екологічні чинники. 



1.4    Бізнес-контекст
1.4.1    Профілі зацікавлених сторін


Таблиця 1.1 – Профілі зацікавлених сторін


Зацікавлена сторона
Головна цінність

Ставлення

Головні інтереси

Обмеження
Центри занурень
Зменшення витрат організацію занурень;
Підвищення безпеки.
Розглядають як проєкт для збільшення якості спостереження за дайверами під час занурення.
Спостереження за станом нирця та зберігання інформації про нього та його спорядження.
Доступ до Інтернету;
Необхідність купляти спеціальне спорядження. 
Нирці
Можливість переглядати графік діяльності центрів. 
Сприйнятлеве, але очікують високий рівень реалізації.
Графік діяльностей центрів;
Простота використання;
Висока надійність.
Повинні працювати на недорогих пристроях;
Доступ до Інтернету;
Наявність відповідного спорядження.
Розробники
Гроші.
Можливість отримання заробітку та підвищення особистих навичок.
Монетизованність.
Труднощі під час реалізації.



1.4.2    Пріоритети проєкту

	Таблиця 1.2 – Пріоритети проєкту

Показник
Виконання (етапи)
Обмеження (граничні значення)
Ступінь свободи (допустимий діапазон)
План робіт
Версія 1.0 має бути готова до 12.06.24.
Розробка частин проєкту має бути виконана у зазначені сроки.
Потрібно обов’язково вкластися у зазначені терміни
Функціональність
Розробка всього зазначеного функціоналу з випуску 1.0 у серверній частині, веб частиніта ІоТ
Розробка до випуску 1.0
Увесь головний функціонал проєкту має бути присутнім на релізі.
Якість
Перевірка проєкту на помилки у системі.
Відсутність фатальних помилок системи.
Треба досягти мінімальної кількості багів у випуску 1.0 .
Персонал
Печерій О. В.
Максимальний розмір команди - одна людина.
Тільки одна людина.
Ціна
Витрати не передбачені.
Бюджет відсутній.
Не потребує.




1.4.3    Робоче середовище

Для серверної частини буде використовуватися мова програмування Python, зокрема Django, як один з найпопулярніших рішень для розробки серверної частини системи. Visual Studio Code буде використовуватися в якості IDE. 
Також в розробці серверної частини буде використовуватися така СУБД як PostgreSQL. PostgreSQL обрано за його надійність, потужність в питанні роботи з даними та підтримку складних запитів. Це одна з найнадійніших і найбільш функціональних реляційних баз даних, яка забезпечує високу продуктивність та зручність в управлінні даними. PostgreSQL також підтримує розширюваність та відповідність SQL стандартам, що робить його ідеальним для масштабних проектів, таких як система автоматизації аквалангічних занурень.
Front-end буде розроблений з використанням бібліотеки React. React - це сучасна бібліотека JavaScript для створення користувацьких інтерфейсів у веб-додатках. Вона є однією з найпопулярніших бібліотек для розробки веб-додатків. Також будуть використовуватися технології HTML та CSS.
Код для декомпресійного компьютеру для занурення буде написаний за допомогою мови C++, використовуючи таку бібліотеку як Arduino. В якості IDE буде використовуватися Arduino IDE.


2 ПОСТАНОВКА ЗАДАЧІ


Програмна система для автоматизації аквалангічних занурень “DeepDive” повина мати наступний функціонал визначений далі.
Реєстрація, вхід та вихід з системи. Забезпечення процесу створення облікового запису новими користувачами шляхом введення основної інформації (електронна пошта, пароль). Можливість входу в систему для вже зареєстрованих користувачів з використанням електронної пошти та пароля. Забезпечення можливості користувачам безпечно виходити з системи.
Надання користувачам можливості переглядати графіки діяльності дайвінг-клубів та шкіл, включаючи розклад занятьІнформація має бути представлена у зручному та зрозумілому форматі.
Збір та відображення даних про стан аквалангістів під час занурення, включаючи глибину та час занурення. Інформація має бути доступна у реальному часі для інструкторів та адміністраторів з метою забезпечення безпеки та покращення навчального процесу.
Автоматизація процесу розподілу спорядження серед аквалангістів. Система повинна забезпечувати ефективне керування запасами спорядження, включаючи його бронювання, видачу та повернення. Це дозволить знизити ризик помилок та забезпечити наявність необхідного обладнання у потрібний час.
Надання функціоналу для управління інформацією про організаторів. Це допоможе забезпечити актуальність даних та полегшити комунікацію між користувачами та організаторами.
Забезпечення можливості створення, читання, оновлення та видалення (CRUD) даних у системі. Це включає управління інформацією про користувачів, спорядження, занурення, графіки та інші важливі елементи системи. Інтерфейс має бути зручним та інтуїтивно зрозумілим для користувачів різного рівня підготовки.
Функціонал для створення резервних копій бази даних з метою забезпечення безпеки та збереження даних. Система повинна автоматично створювати копії на регулярній основі та надавати можливість відновлення даних у випадку збою або втрати інформації.
Програмне забезпечення для пристроїв IoT має забезпечувати збір даних про стан аквалангіста під час занурення та їх передачу до центральної системи в режимі реального часу. Це включає показники глибини та часу занурення. Дані мають бути надійно зашифровані для забезпечення конфіденційності.
Надання адміністраторам повного доступу до управління даними у системі, включаючи інформацію про користувачів, спорядження, занурення та графіки. Адміністратори повинні мати можливість редагувати, видаляти та створювати нові записи, а також керувати ролями та правами доступу користувачів.
Розробка графічного інтерфейсу, який буде інтуїтивно зрозумілим та зручним для користувачів. Інтерфейс повинен бути простим у навігації та забезпечувати швидкий доступ до всіх основних функцій системи.


3 ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
3.1    Проектування серверної частини проєкту


Першим кроком чітко визначити та описати всі необхідні сутності системи для реалізації визначеного функціоналу. Цьому допоможе розробка ER-моделі даних, яка візуалізує всі сутності ті зв’язки між ціми сутностями. Після того, як були визначені усі сутності була створена ER-модель даних(див. рис. Б.1 у додатку Б). 
	Модель даних включає в себе наступні сутності та поля:
	а) користувач:
		1) користувач_id;
	2) пароль;
	3) елелктрона_пошта;
	4) ім’я;
	5) прізвище;
	6) роль;
	7) дата_створення;
	8) зріст;
	9) розмір_ноги;
б) організатор:
	1) організатор_id;
	2) ім’я;
	3) тип;
в) спорядження:
	1) спорядження_id;
	2) організатор_id;
	3) розмір_костюму_id;
	4) ім’я;
	5) тип;
	6) розмір;
	7) використовується;
г) розмір_костюму:
	1) розмір_костюму_id;
	2) розмір; 
д) комп’ютер_для_занурення:
	1)  комп’ютер_для_занурення_id;
	2) глибина;
	3) час_занурення;
е) діяльність:
	1) діяльність_id;
	2) організатор_id;
	3) ім’я;
	4) країна;
	5) опис;
	6) місця;
	7) час;
є) участь:
	1) участь_id;
	2) діяльность_id;
	3) користувач_id;
	4) спорядження_id;
	5) группа;
	6) спорядження_розподілене;
	ж) користувач-організатор:
		1) користувач-організатор_id;
		2) користувач_id;
		3) організатор_id;
	4) позиція.
	Описанні вище сутності та поля мають усе необхідне для реалізації запланованого функціоналу системи.
Тепер, коли всі сутності були визначені ми можемо перейти до сценаріїв використання системи. Увесь функціонал описаний раніше був розподілений між пятью акторами, а саме: гість, користувач, організатор, адміністратор та датчик. Під час першого використання системи, людина є гістем. Гість може лише переглядати інформацію, таку як інформацію про організаторів та список запланованих діяльностей. Щоб отримати доступ до іншого функціоналу системи, йому потрібно зареєструватися та увійти до системи.
	Людина може увійти до системи як користувач, організатор чи адміністратор. Користувач має можливість переглядати та редагувати інформацію про себе. Окрім цього він може приєднатися до участі до зазначеної діяльності.
	Організатор має можливість переглядати та редагувати інформацією про організаторів, про діяльності та про спорядження, що вони використовують. 
	Адміністратор має доступ до будь-якого функціоналу та інформації у системі. Також він має можливість створення запасної копії бази даних. 
	Датчик вимірює поточну глибину та час занурення та надає цю інформацію системі.
	На основі представленних сценаріїв використання системи була створена UML діаграма прецедентів(див. рис. Б.2 у додатку Б). Таким чином, в результаті концептуального моделювання предметної області, були визначені основні сутності програмної системи, поля, що їм належать, та створені дві діаграми. 
Спілкування між серверною і клієнтською частинами, а також з мобільним додатком та IoT, реалізоване за допомогою REST API. Цей тип спілкування забезпечує загальну структуру взаємодії та дозволяє легко додавати різні компоненти системи. Більш детальна інформація про взаємодію різних частин системи може бути представлена на UML-діаграмі розгортання (див. рис. 3.1).


Рисунок 3.1 - UML діаграма розгортання серверної частини

	Для демонстрації головного для користувача функціоналу, а саме створення та запис на участь у діяльності з занурення, була розроблена діаграма активності (див. рис. 3.2). На неї відображено головні дії та етапи, які потрібно здійснити користувачеві та організатори для досягнення мети. 


Рисунок 3.2 - UML діаграма активності


	3.2    Проектування IoT-частини системи


	IoT частина розробленого проекту взаємодіє з актором користувача, коли той робить занурення. Пристрій вимірює глибину та заміряє час запливу та відправляє дані на сервер, які потім виводяться у системі організатору занурення. Ця взаємодія представлена на діаграмі прецедентів (див. рис. 3.3).


Рисунок 3.3 - UML діаграма прецедентів IoT частини системи

За допомогою даної діаграми були окреслені функціональні вимоги до IoT частини проекту.	


3.4    Проектування клієнтської частини системи


Системою користуються чотири типи акторів: гість, користувач, організатор та адміністратор. Під час першого використання система дозволяє гостю лише переглядати інформацію про організаторів та список запланованих діяльностей. Для доступу до іншого функціоналу гість повинен зареєструватися та увійти до системи.
Користувач може приєднуватися до діяльностей. Організатор має доступ до перегляду та редагування інформації про організаторів, діяльності та спорядження. Адміністратор має повний доступ до функціоналу та інформації в системі, а також може створювати запасні копії бази даних.
Для демонстрації вище означених сценаріїв була створена UML діаграма прецедентів (див. рис. Б.2 у додатку Б).



4 КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
4.1    Кодування серверної частини системи


Вибір технологій для розробки серверної частини був заснований відповідно до функціональних вимог. Для написання серверної частини було обрано фреймворк Django у поєднанні з Django REST Framework для реалізації RESTful веб-сервісів. Django надає широкий функціонал для швидкої розробки веб-додатків, а Django REST Framework спрощує створення API на основі архітектурного стилю REST.
Система використовує архітектуру MTV. Даний архітектурний стиль використовується в Django для побудови веб-додатків. У цій архітектурі, модель відповідає за представлення даних та бізнес-логіку, виноситься на вищий рівень для спрощення розробки та підтримки коду. Вид обробляє запити користувача, взаємодіє з моделлю для отримання необхідних даних та передає їх у шаблон для відображення. Ця структура чітко розділяє обов'язки між компонентами, полегшуючи розробку та підтримку коду, та сприяє швидкості розробки за рахунок використання вбудованих функцій та шаблонів.
У ролі бази даних було обрано PostgreSQL[3], оскільки вона є потужною реляційною базою даних, яка надає велику кількість функцій для забезпечення ефективного зберігання та операцій з даними. Окрім цього Django має вбудовану підтримку PostgreSQL, що робить інтеграцію з цією базою даних дуже простою. Вона підтримує всі функції Django ORM та може легко взаємодіяти з іншими компонентами Django, такими як адміністративний інтерфейс та форми.
Система має стандартную структуру для проекту Django, яка складається з наступних компонентів:
а) Каталог Django Project:
1) Файл manage.py, який здійснює запуск сервера;
2) Файл settings.py, який зберігає налаштування проекту;
3) Файл urls.py, який зберігає конфігурацію проекту;
4) Файл api_urls.py, який зберігає конфігурацію пов’язану зі взаємодією з веб-клієнтом;
б) Каталог Django App:
1) Файл models.py, де описуються моделі;
2) Файл views.py для визначення логіки та обробки запитів; 
3) Файл forms.py для визначення форм для обробки введення.
4) Файл backup_db.py для збереження функціоналу з                                 резервного копіювання бази даних;
5) Каталог backups, для збереження копій бази даних;
Специфікація REST API та функцій які взаємодіють з веб-сервісами наведена нижче в таблиці 4.1.

Таблиця 4.1 - Специфікація REST API серверної частини системи
Сутність
Метод
Посилання
Дія
Користувачi
POST
login/
Увійти до системи
register/
Реєстрація нового користувача
backup/
Створення резервної копії бази даних
GET
logout/
Вихід із системи
Організатори
GET
organizers/
Виводить список всіх організаторів



Продовження таблиці 4.1
Сутність
Метод
Посилання
Дія
Організатори
GET
organizers/<int:id>/
Виводить деталі конкретного організатора
POST
organizers/create/
Створення нового організатора
organizers/<int:id>/update/
Оновлення існуючого організатора
DELETE
organizers/<int:id>/delete/
Видалення існуючого організатора
Спорядження
GET
gears/
Виводить список усього спорядження
gears/<int:id>/
Виводить деталі конкретного спорядження
POST
gears/create/
Створення нового спорядження
gears/<int:id>/update/
Оновлення існуючого спорядження
DELETE
gears/<int:id>/delete/
Видалення існуючого спорядження



Продовження таблиці 4.1
Сутність
Метод
Посилання
Дія
Комп’ютер для занурення
GET
dive_computers/
Виводить список всіх комп'ютерів
dive_computers/<int:id>/
Виводить деталі конкретного комп’ютера
POST
dive_computers/create/
Створення нового комп’ютера
dive_computers/<int:id>/update/
Оновлення існуючого комп’ютера
DELETE
dive_computers/<int:id>/delete/
Видалення існуючого комп’ютера
Діяльність
GET
activities/
Виводить список усіх діяльностей
activities/<int:id>/
Виводить деталі конкретної діяльності
POST
activities/create/
Створення нової діяльності
activities/<int:id>/update/
Оновлення існуючої діяльності


	Продовження таблиці 4.1
Сутність
Метод
Посилання
Дія
Діяльність
POST
activities/<int:id>/distribute-gear/
Розподіл спорядження
activities/<int:id>/distribute-gear/
Звільнення спорядження
DELETE
activities/<int:id>/delete/
Видалення існуючої діяльності
Участь
GET
participations/
Виводить список всіх участей
participations/<int:id>/
Виводить деталі конкретної участі
POST
participations/create/
Створення нової участі
participations/<int:id>/update/
Оновлення існуючої участі
DELETE
participations/<int:id>/delete/
Видалення існуючої участі



4.1.1    Автоматизація розподілу спорядження


Основна мета методу gear_distribution це автоматизація процесу розподілу спорядження між групою учасників діяльності, що містить в собі обробку даних користувачів та представляє собою важливу частину бізнес-логіки.
Перш за все, метод gear_distribution перевіряє метод запиту та отримує потрібну активність (див. рядки 2-7, розділ А.1 у додатку А). Це важливо для забезпечення коректності обробки запиту та надання відповіді користувачу.
Далі, метод перебирає усіх учасників у циклі та для кожного учасника ми перебираємо доступне спорядження, яке відповідає розміру та типу (див. рядки 11-33, розділ А.1 у додатку А). Якщо спорядження знайдено, воно резервується для участника (див. рядки 36-47, розділ А.1 у додатку А). Це важливо для забезпечення кожного учасника необхідним спорядженням для здійснення активності.
У методі також перевіряється коректність обробки запиту та надається відповідна відповідь у разі, якщо тип запиту не підтримується (див. рядки 56-57, розділ А.1 у додатку А). 


4.1.2    Створення копії бази даних

Метод get_backup_directory відповідає за створення каталогу для збереження копій бази даних. Він використовує шлях до поточного файлу для визначення шляху до додаткового каталогу "backups", куди будуть збережені копії. Якщо каталог не існує, він буде створений. Ця функція допомагає підготувати середовище для збереження резервних копій перед їх створенням.
Метод backup_database відповідає за створення копії бази даних PostgreSQL. Він використовує pg_dump для створення файлу копії в форматі "custom" (-Fc) (див. рядок 19 розділ А.2 у додатку А), що дозволяє зберегти схему та дані бази даних у бінарному форматі. Резервна копія зберігається у вказаному каталогу, з ім'ям файлу, яке містить дату та час створення копії. Цей метод є важливою частиною бізнес-логіки для забезпечення безпеки та захисту даних, оскільки дозволяє швидко відновлювати базу даних в разі її пошкодження або втрати.


4.1.3 Перевірка даних при вводі на правильність


Може існувати ситуація, коли дані, що ввів користувач не відповідають встановленим системою правилам. Для цього була введена перевірка даних при вводі, що є невід’ємною частиною бізнес-логіки. Якщо користувач, наприклад, ввів свою електронну пошту в неправильному форматі чи при реєстрації надав занадто простий пароль, то при данній перевірці система видасть виключення та повідомляє про це користувача. Це забезпече коректність даних та підвищить захищеність системи, покращуючи її бізнес-логіку. Код наведених функцій наведений у додатках(див. розділ А.3 у додатку А).


4.2 Кодування IoT-частини системи


Для реалізації функціональностей IoT частини системи використано мову програмування Arduino (.ino). Програма взаємодіє з сервером за допомогою бібліотеки WiFi та HTTPClient і використовує протокол HTTP для обміну даними.
Зчитування даних із сенсора реалізоване за допомогою бібліотеки HX711, яка забезпечує отримання даних з вагового датчика. Програма з'єднується з Wi-Fi мережею, після чого готова надсилати дані на сервер.
Надсилання даних реалізоване за допомогою HTTP POST-запиту, де дані формуються у форматі application/x-www-form-urlencoded. Відправляються дані про глибину занурення і тривалість занурення. Використання даного формату дозволяє структуровано представляти дані та забезпечує зручний обмін інформацією між IoT пристроєм і сервером.
Оптимізація коду здійснена для роботи на пристроях з обмеженою потужністю, забезпечуючи можливість легкого портування програми на реальні IoT пристрої. Використання бібліотеки HTTPClient у сполученні з мовою Arduino дозволяє досягти ефективного взаємодії та оптимального використання ресурсів пристрою для передачі даних на сервер.
Як було зазначено вище, для написання IoT частини системи була обрана мова програмування Arduino. Компіляція коду відбувається за допомогою Arduino IDE чи за допомогою Wokwi.
Для створення запитів відбувається за допомогою бібліотеки WiFi та HTTPClient. Для повного розуміння використаних технологій була створена діаграма пакетів (див. рис. 4.1).



Рисунок 3.1 - UML діаграма пакетів для IoT частини системи

Для демонстрації взаємодії пристрою з користувачем системи більш детально було розроблено діаграму взаємодії (див. додат. Б.3). Окрім цього, на основі взаємодії пристрою було побудовано діаграму діяльності де можно побачити взаємодію пристрою з сервером (див. додат. Б.4).
	4.3    Кодування веб-клієнту частини


	Обрання технології для цього проекту відбувалося на підстави функціональних вимог та особитсих навичок. Для написання веб-частини проекту був обраний React[4] у поєднанні з JavaScript. Обрані технології дозволяють забезпечити високу продуктивність та ефективність системи.
Для роботи з формами та управлінням станом використовуються стандартні React хуки, такі як useState та useEffect, що спрощує управління станом та побудову логіки додатку. Axios використовується для здійснення HTTP-запитів до сервера, забезпечуючи зручний спосіб роботи з API.
Обраним архітектурним стилем є SPA (Single Page Application) – це тип веб-додатку, що взаємодіє з користувачем шляхом динамічного перезавантаження поточної веб-сторінки, замість завантаження нових сторінок з сервера. Це забезпечує швидший і більш інтерактивний користувацький досвід, оскільки більшість логіки програми виконується на стороні клієнта в браузері, а сервер виконує лише функції, пов'язані з даними.
	Для більш детального відображення структуру веб-частини проекту була створена діаграма компонентів (див. рис. 4.2).


Рисунок 4.2 - UML діаграма компонентів веб-клієнту системи

Для опису поведінки системи та її станів, була розроблена та наведена діаграма станів (див. рис. 4.3). На ній було показано такі стани користувача, як неавторизований, авторизований, активний та стани в які переходить користувач в системі під час праці.


Рисунок 4.3 - UML діаграма станів веб-клієнту системи

	Для демонстрації усіх можливих дій для користувача в системі була розроблена діаграма діяльності (див. рис. 4.4). На неї детально відображено які саме дії  доступні користувачеві та етапи, через які нужно пройти, що їх здійснити. 


Рисунок 4.4 - UML діаграма діяльності веб-клієнту системи

4.3.1    Перевід значень глибини та часу

	Система має функцію конвертацію значень глибини та часу і відображає їх на веб-сторінці діяльності (див. стр. 97-105 у розділі А.5 у додат. А). Головне призначення даного коду - це перевід значень глибини та часу занурення у різні системи вимірювання, такі як, наприклад, фіти.


ВИСНОВКИ
     
     
     В рамках курсового проекту було проведено концептуальне моделювання та поглиблений аналіз предметної області автоматизації аквалангичних занурень. На основі цього аналізу була розроблена програмна система для підвищення зручності управління зануреннями та надання інструментів організаторам та користувачам.
Розробка включала в себе створення концептуальної моделі всіх частин системи, яка дозволила нам краще зрозуміти потреби користувачів та визначити основні вимоги до неї. Була розроблена фізична модель даних. Серверна частина була реалізована на платформі Python з використанням Django для створення веб-сервісу RESTful. База даних реалізована на PostgreSQL для забезпечення високої продуктивності і надійності зберігання даних. На стороні клієнта була використана бібліотека React для забезпечення динамічного та інтерактивного інтерфейсу користувача. Код для декомпресійного підводного комп'ютера був написаний на C++ за допомогою бібліотеки Arduino
В результаті проведеної роботи була створена програмна система “DeepDive”, яка надає користувачам інструменти для ефективного управління процесом занурення, забезпечує зручний доступ до інформації, відстежує стан аквалангістів в режимі реального часу і автоматизує розподіл спорядження. Система також дозволяє створювати резервні копії баз даних для забезпечення безпеки та відновлення даних.
В цілому, розроблена система автоматизації аквалангічний занурень є зручним інструментом для організаторів, інструкторів та звичайних користувачів, які займаються зануреннями. Вона не тільки забезпечує простоту і ефективність управління процесом занурення, але і спрощує організаційний процес для управління діяльностями.



ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


Про Geek Divers: https://geekdivers.com/ (дата звернення 20.04.2024)
Про Nautilus: https://nautilus.logystech.com/ (дата звернення 4.05.2024)
Документація PostgreSQL: https://www.postgresql.org/docs/ (дата звернення 18.05.2024)
Документація React: https://legacy.reactjs.org/docs (дата звернення 1.06.2024)
Демонстрація тестування розробленої програмної системи:https://youtu.be/X35avYsunAE
GitHub репозитроій проекту. URL: https://github.com/NurePecheriiOleksandr/apzkr-pzpi-21-4-pecherii-oleksandr


ДОДАТОК А
Код програми


А.1 Код автоматизації розподілу спорядження


1  def gear_distribution(request, activity_id):
2      if request.method == 'POST':
3          activity = get_object_or_404(Activity, id=activity_id)
4          organizer = activity.organizer
5  
6          if not request.user.role in ['org', 'admin'] and request.user != organizer:
7              return JsonResponse({'error': 'You are not permitted to perform this action.'}, status=403)
8  
9          participations = Participation.objects.filter(activity=activity)
10  
11         for participation in participations:
12             # Get all available gear for the organizer
13             available_gear = Gear.objects.filter(organizer=organizer, is_reserved=False)
14  
15             # Filter available gear by user's size and gear type
16             for gear_type in Gear.GEAR_TYPE_CHOICES:
17                 user_gear = participations.filter(user=participation.user, gear__gear_type=gear_type[0]).first()
18  
19                 if not user_gear:
20                     # User does not have this type of gear yet
21                     if gear_type[0] == 'Wetsuit':
22                         # For wetsuits, also consider the wetsuit size
23                         gear = available_gear.filter(
24                             gear_type=gear_type[0],
25                             wetsuit_size__size__in=[
26                                 participation.user.height,
27                                 participation.user.foot_size
28                             ]
29                         ).first()
30                     else:
31                         gear = available_gear.filter(
32                             gear_type=gear_type[0],
33                             size__in=[participation.user.height, participation.user.foot_size]
34                         ).first()
35  
36                     if gear:
37                         # Reserve the gear for this participation
38                         gear.is_reserved = True
39                         gear.save()
40  
41                         # Assign the reserved gear to the participation
42                         participation.gear = gear
43                         participation.is_gear_reserved = True
44                         participation.save()
45  
46                         # Update gear_id field in participation
47                         participation.gear_id = gear.id
48                         participation.save()
49  
50                         # Ensure the user doesn't have more than one gear of each type
51                         participations.filter(user=participation.user, gear__gear_type=gear_type[0]).exclude(
52                             id=participation.id).update(is_gear_reserved=False)
53  
54                         break  # Stop searching for gear once one is found for this user
55  
56         return JsonResponse({'message': 'Gear distribution completed successfully.'})
57     else:
58         return JsonResponse({'error': 'This view only accepts POST requests.'}, status=405)


А.2 Код для створення копії бази даних


1  def get_backup_directory():
2      script_directory = os.path.dirname(os.path.abspath(__file__))
3      app_directory = os.path.dirname(script_directory)
4      backup_directory = os.path.join(app_directory, 'backups')
5      if not os.path.exists(backup_directory):
6          os.makedirs(backup_directory)
7      return backup_directory
8  
9  def backup_database(host, port, database, user, password):
10     try:
11         timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
12         backup_directory = get_backup_directory()
13         backup_file = os.path.join(backup_directory, f'backup_{timestamp}.sql')
14  
15         # Full path to pg_dump executable
16         pg_dump_path = 'C:\\Program Files\\PostgreSQL\\16\\bin\\pg_dump.exe'
17  
18         # Command to perform schema and data backup using pg_dump
19         pg_dump_command = [
20             pg_dump_path,
21             '-h', host,
22             '-p', port,
23             '-U', user,
24             '-d', database,
25             '-Fc',
26             '-f', backup_file
27         ]
28  
29         subprocess.run(pg_dump_command, check=True)
30  
31         print(f"Backup successful. Backup file saved as: {backup_file}")
32  
33     except subprocess.CalledProcessError as error:
34         print("Error while backing up PostgreSQL database:", error)


	А.3 Перевірка даних на правильність вводу


1  def clean_email(self):
2      email = self.cleaned_data.get('email')
3      if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
4          raise forms.ValidationError("Please enter a valid email address.")
5      return email
6  
7  def clean_password(self):
8      password = self.cleaned_data.get('password')
9      if len(password) < 8:
10         raise forms.ValidationError("Password must be at least 8 characters long.")
11     return password


	А.4 Код IoT пристрою


1 #include <WiFi.h>
2 #include <HTTPClient.h>
3 #include "HX711.h"
4
5 const char* ssid = "Wokwi-GUEST";
6 const char* password = "";
7 const char* server = "http://localhost:8000/update_dive_computer_data";
8 const char* dive_computer_id = "1";  
9
10 HX711 scale;
11
12 const float atmosphericPressure = 101325; // Атмосферний тиск в Па
13 const float waterDensity = 1025; // Щільність води в кг/м^3
14 const float gravity = 9.81; // Прискорення вільного падіння в м/с^2
15
16 unsigned long diveStartTime;
17 bool isDiving = false;
18
19 void setup() {
20   Serial.begin(9600);
21   Serial.println("Dive Computer Prototype");
22
23   scale.begin(16, 17);
24   scale.set_scale(30.f);
25   scale.tare();
26
27   WiFi.begin(ssid, password);
28   Serial.print("Connecting to Wi-Fi");
29   while (WiFi.status() != WL_CONNECTED) {
30     delay(500);
31     Serial.print(".");
32   }
33   Serial.println(" Connected to Wi-Fi");
34
35   Serial.println("Depth sensor initialized. Ready to dive!");
36 }
37
38 void loop() {
39   float rawReading = scale.get_units(5);
40
41   rawReading = max(rawReading, 0.0f);
42
43   float pressure = rawReading * 1000 + atmosphericPressure;
44   float depth = (pressure - atmosphericPressure) / (waterDensity * gravity);
45
46   if (rawReading < 1.0) {
47     depth = 0.0;
48   }
49
50   Serial.print("Depth: ");
51   Serial.print(depth, 2);
52   Serial.println(" meters");
53
54   if (depth > 1 && !isDiving) {
55     isDiving = true;
56     diveStartTime = millis();
57   }
58
59   unsigned long diveTime = 0;
60   if (isDiving) {
61     diveTime = (millis() - diveStartTime) / 1000;
62   }
63
64   Serial.print("Dive Time: ");
65   Serial.print(diveTime);
66   Serial.println(" seconds");
67
68   if (WiFi.status() == WL_CONNECTED) {
69     HTTPClient http;
70     http.setTimeout(5000); 
71     Serial.println("Starting POST request");
72     http.begin(server);
73     http.addHeader("Content-Type", "application/x-www-form-urlencoded");
74
75     String postData = "id=" + String(dive_computer_id) + "&depth=" + String(depth, 2) + "&diveTime=" + String(diveTime);
76     int httpResponseCode = http.POST(postData);
77
78     if (httpResponseCode > 0) {
79       String response = http.getString();
80       Serial.println(httpResponseCode);
81       Serial.println(response);
82     } else {
83       Serial.print("Error on sending POST: ");
84       Serial.println(httpResponseCode);
85     }
86
87     http.end();
88   }
89
90   delay(1000);
91 }


	А.5 Код сторінки ActivityDetail


1  import React, { useEffect, useState } from 'react';
2  import { useParams, Link } from 'react-router-dom';
3  import axiosInstance from './axiosInstance';
4  import { useUser } from '../UserContext';
5  import styles from './ActivityDetail.module.css';
6  
7  const ActivityDetail = () => {
8      const { id } = useParams();
9      const [activity, setActivity] = useState(null);
10     const [isOrgOrAdmin, setIsOrgOrAdmin] = useState(false);
11     const [diveComputers, setDiveComputers] = useState([]);
12     const { user } = useUser();
13     const [depthMetric, setDepthMetric] = useState('meters');
14     const [timeMetric, setTimeMetric] = useState('minutes');
15 
16     useEffect(() => {
17         const fetchActivity = async () => {
18             try {
19                 const response = await axiosInstance.get(`/api/activities/${id}/`);
20                 console.log('Fetched activity:', response.data);
21                 setActivity(response.data);
22             } catch (error) {
23                 console.error('Failed to fetch activity', error);
24             }
25         };
26 
27         const fetchCurrentUser = async () => {
28             try {
29                 const response = await axiosInstance.get('/api/current_user/');
30                 const user = response.data;
31                 console.log('Current user:', user);
32                 setIsOrgOrAdmin(user.role === 'org' || user.role === 'admin');
33             } catch (error) {
34                 console.error('Failed to fetch current user', error);
35             }
36         };
37 
38         const fetchDiveComputers = async () => {
39             try {
40                 const response = await axiosInstance.get('/api/dive_computers/');
41                 console.log('Fetched dive computers:', response.data);
42                 setDiveComputers(response.data);
43             } catch (error) {
44                 console.error('Failed to fetch dive computers', error);
45             }
46         };
47 
48         fetchActivity();
49         fetchCurrentUser();
50         fetchDiveComputers();
51     }, [id]);
52 
53     const handleParticipate = async () => {
54         try {
55             await axiosInstance.post(`/api/activities/${id}/participate/`);
56             const response = await axiosInstance.get(`/api/activities/${id}/`);
57             setActivity(response.data);
58         } catch (error) {
59             console.error('Failed to participate', error);
60         }
61     };
62 
63     const handleDiveComputerChange = async (participationId, diveComputerId) => {
64         console.log('Updating participation:', participationId, 'with dive computer:', diveComputerId);
65         try {
66             await axiosInstance.put(`/api/participations/${participationId}/`, { dive_computer: diveComputerId || null });
67             const response = await axiosInstance.get(`/api/activities/${id}/`);
68             console.log('Updated activity after dive computer change:', response.data);
69             setActivity(response.data);
70         } catch (error) {
71             console.error('Failed to update dive computer', error);
72         }
73     };
74 
75     const handleDistributeGear = async () => {
76         try {
77             const response = await axiosInstance.post(`/api/activities/${id}/distribute_gear/`);
78             console.log('Gear distribution response:', response.data);
79             const updatedActivity = await axiosInstance.get(`/api/activities/${id}/`);
80             setActivity(updatedActivity.data);
81         } catch (error) {
82             console.error('Failed to distribute gear', error);
83         }
84     };
85 
86     const handleFreeGear = async () => {
87         try {
88             const response = await axiosInstance.post(`/api/activities/${id}/free_gear/`);
89             console.log('Free gear response:', response.data);
90             const updatedActivity = await axiosInstance.get(`/api/activities/${id}/`);
91             setActivity(updatedActivity.data);
92         } catch (error) {
93             console.error('Failed to free gear', error);
94         }
95     };
96 
97     const convertDepthToFeet = (meters) => {
98         return (meters * 3.28084).toFixed(2); // 1 meter = 3.28084 feet
99     };
100 
101    const convertTimeToHoursMinutes = (minutes) => {
102        const hours = Math.floor(minutes / 60);
103        const remainingMinutes = minutes % 60;
104        return `${hours}h ${remainingMinutes}m`;
105    };
106 
107    const handleDepthMetricChange = (e) => {
108        setDepthMetric(e.target.value);
109    };
110 
111    const handleTimeMetricChange = (e) => {
112        setTimeMetric(e.target.value);
113    };
114 
115    if (!activity) {
116        return <div>Loading...</div>;
117    }
118 
119    return (
120        <div className={styles.activityDetailContainer}>
121            <h1>{activity.activity_name}</h1>
122            <div className={styles.activityDetails}>
123                <p><strong>Date:</strong> {new Date(activity.activity_date_time).toLocaleString()}</p>
124                <p><strong>Country:</strong> {activity.country}</p>
125                <p><strong>Description:</strong> {activity.description}</p>
126                <p><strong>Organizer:</strong> {activity.organizer_name}</p>
127            </div>
128            
129            <h2>Participations</h2>
130            {user.role === 'user' ? (
131                <ul>
132                    {activity.participations.map(participation => (
133                        <li key={participation.id}>
134                            {participation.user.first_name} {participation.user.last_name}
135                        </li>
136                    ))}
137                </ul>
138            ) : (
139                <div>
140                    {isOrgOrAdmin && (
141                        <div className={styles.metricSelectors}>
142                            <label>
143                                Depth:
144                                <select value={depthMetric} onChange={handleDepthMetricChange}>
145                                    <option value="meters">Meters</option>
146                                    <option value="feet">Feet</option>
147                                </select>
148                            </label>
149                            <label>
150                                Dive Time:
151                                <select value={timeMetric} onChange={handleTimeMetricChange}>
152                                    <option value="minutes">Minutes</option>
153                                    <option value="hours">Hours</option>
154                                </select>
155                            </label>
156                        </div>
157                    )}
158                    <table className={styles.participationTable}>
159                        <thead>
160                            <tr>
161                                <th>Name</th>
162                                <th>Gear</th>
163                                <th>Dive Computer</th>
164                                <th>Assign Dive Computer</th>
165                                <th>Set Gear to Null</th>
166                            </tr>
167                        </thead>
168                        <tbody>
169                            {activity.participations.map(participation => (
170                                <tr key={participation.id}>
171                                    <td>{participation.user.first_name} {participation.user.last_name}</td>
172                                    <td>{participation.gear ? participation.gear.gear_name : 'No gear assigned'}</td>
173                                    <td>
174                                        {participation.dive_computer ? (
175                                            <>
176                                                Depth: {depthMetric === 'meters' ? participation.dive_computer.depth : convertDepthToFeet(participation.dive_computer.depth)} {depthMetric === 'meters' ? 'm' : 'ft'}, 
177                                                Dive Time: {timeMetric === 'minutes' ? participation.dive_computer.dive_time : convertTimeToHoursMinutes(participation.dive_computer.dive_time)} {timeMetric === 'minutes' ? 'min' : ''}
178                                            </>
179                                        ) : (
180                                            'No dive computer assigned'
181                                        )}
182                                    </td>
183                                    <td>
184                                        <select
185                                            value={participation.dive_computer ? participation.dive_computer.id : ''}
186                                            onChange={(e) => handleDiveComputerChange(participation.id, e.target.value)}
187                                        >
188                                            <option value="">Select Dive Computer</option>
189                                            {diveComputers.map(dc => (
190                                                <option key={dc.id} value={dc.id}>
191                                                    {dc.id}
192                                                </option>
193                                            ))}
194                                        </select>
195                                    </td>
196                                    <td>
197                                        <button onClick={() => handleDiveComputerChange(participation.id, null)}>Set Gear to Null</button>
198                                    </td>
199                                </tr>
200                            ))}
201                        </tbody>
202                    </table>
203                </div>
204            )}
205 
206            <div className={styles.buttonGroup}>
207                {isOrgOrAdmin && (
208                    <>
209                        <Link to={`/activities/edit/${id}`}><button>Upgrade</button></Link>
210                        <button onClick={handleDistributeGear}>Distribute Gear</button>
211                        <button onClick={handleFreeGear}>Free Gear</button>
212                    </>
213                )}
214                <button onClick={handleParticipate}>Participate</button>
215            </div>
216        </div>
217    );
218 };
219 
220 export default ActivityDetail;



ДОДАТОК Б
Діаграми



Рисунок Б.1 – ER модель даних


Рисунок Б.2 - UML діаграма прецедентів



Рисунок Б.3 – Діаграма взаємодії для IoT частини системи


Рисунок Б.4 - Діаграма діяльності для IoT частини системи




ДОДАТОК В
Перевірка на плагіат

Ім'я користувача: 
Нестерцова Світлана Олександрівна каф. ПІ 
Дата перевірки: 
10.06.2024 23:37:33 EEST 
Дата звіту: 
10.06.2024 23:57:51 EEST 
ID перевірки: 1016342072 
Тип перевірки: Doc vs Library 
ID користувача: 100008663 

Назва документа: 2024_АПЗ_ПЗПІ_21_4_Печерій_О_В_скорочений.pdf 
Кількість сторінок: 37 Кількість слів: 4843 Кількість символів: 36236 Розмір файлу: 390.59 KB ID файлу: 1016143380 
Виявлено модифікації тексту (можуть впливати на відсоток схожості) 
7.62% 
Схожість 
Найбільша схожість: 3.8% з джерелом з Бібліотеки (ID файлу: 1016121918) 
Пошук збігів з Інтернетом не проводився 

7.62% Джерела з Бібліотеки 309 
0% Цитат 
Вилучення цитат вимкнене 
.......................................................................................................С..т..о..р..і.н..к.а...3..9............

Вилучення списку бібліографічних посилань вимкнене 
0% 
Вилучень 
Немає вилучених джерел 
Модифікації 
Виявлено модифікації тексту. Детальна інформація доступна в онлайн-звіті. Замінені символи 1 
Підозріле форматування7 
сторінок
Назва документа: 2024_АПЗ_ПЗПІ_21_4_Печерій_О_В_скорочений…ID файлу: 1016143380 
